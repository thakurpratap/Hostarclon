{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { getInitialPhoneDigits, getCountryForPartialE164Number, parsePhoneNumber, couldNumberBelongToCountry } from './phoneInputHelpers.js';\nimport { validateE164Number } from './isE164Number.js';\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix.js';\nimport { isCountrySupportedWithError, getSupportedCountries } from './countries.js';\nexport default function getPhoneInputWithCountryStateUpdateFromNewProps(props, prevProps, state) {\n  var metadata = props.metadata,\n    countries = props.countries,\n    newDefaultCountry = props.defaultCountry,\n    newValue = props.value,\n    newReset = props.reset,\n    international = props.international,\n    displayInitialValueAsLocalNumber = props.displayInitialValueAsLocalNumber,\n    initialValueFormat = props.initialValueFormat;\n  var prevDefaultCountry = prevProps.defaultCountry,\n    prevValue = prevProps.value,\n    prevReset = prevProps.reset;\n  var country = state.country,\n    value = state.value,\n    hasUserSelectedACountry = state.hasUserSelectedACountry,\n    latestCountrySelectedByUser = state.latestCountrySelectedByUser;\n  var _getInitialPhoneDigits = function _getInitialPhoneDigits(parameters) {\n    return getInitialPhoneDigits(_objectSpread(_objectSpread({}, parameters), {}, {\n      international: international,\n      useNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === 'national',\n      metadata: metadata\n    }));\n  };\n\n  // Some users requested a way to reset the component\n  // (both number `<input/>` and country `<select/>`).\n  // Whenever `reset` property changes both number `<input/>`\n  // and country `<select/>` are reset.\n  // It's not implemented as some instance `.reset()` method\n  // because `ref` is forwarded to `<input/>`.\n  // It's also not replaced with just resetting `country` on\n  // external `value` reset, because a user could select a country\n  // and then not input any `value`, and so the selected country\n  // would be \"stuck\", if not using this `reset` property.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/300\n  if (newReset !== prevReset) {\n    return {\n      phoneDigits: _getInitialPhoneDigits({\n        value: undefined,\n        defaultCountry: newDefaultCountry\n      }),\n      value: undefined,\n      country: newDefaultCountry,\n      latestCountrySelectedByUser: undefined,\n      hasUserSelectedACountry: undefined\n    };\n  }\n\n  // `value` is the value currently shown in the component:\n  // it's stored in the component's `state`, and it's not the `value` property.\n  // `prevValue` is \"previous `value` property\".\n  // `newValue` is \"new `value` property\".\n\n  // If the default country changed\n  // (e.g. in case of ajax GeoIP detection after page loaded)\n  // then select it, but only if the user hasn't already manually\n  // selected a country, and no phone number has been manually entered so far.\n  // Because if the user has already started inputting a phone number\n  // then they're okay with no country being selected at all (\"International\")\n  // and they don't want to be disturbed, don't want their input to be screwed, etc.\n  if (newDefaultCountry !== prevDefaultCountry) {\n    var isNewDefaultCountrySupported = !newDefaultCountry || isCountrySupportedWithError(newDefaultCountry, metadata);\n    var noValueHasBeenEnteredByTheUser =\n    // By default, \"no value has been entered\" means `value` is `undefined`.\n    !value ||\n    // When `international` is `true`, and some country has been pre-selected,\n    // then the `<input/>` contains a pre-filled value of `+${countryCallingCode}${leadingDigits}`,\n    // so in case of `international` being `true`, \"the user hasn't entered anything\" situation\n    // doesn't just mean `value` is `undefined`, but could also mean `value` is `+${countryCallingCode}`.\n    international && value === _getInitialPhoneDigits({\n      value: undefined,\n      defaultCountry: prevDefaultCountry\n    });\n    // Only update the `defaultCountry` property if no phone number\n    // has been entered by the user or pre-set by the application.\n    var noValueHasBeenEntered = !newValue && noValueHasBeenEnteredByTheUser;\n    if (!hasUserSelectedACountry && isNewDefaultCountrySupported && noValueHasBeenEntered) {\n      return {\n        country: newDefaultCountry,\n        // If `phoneDigits` is empty, then automatically select the new `country`\n        // and set `phoneDigits` to `+{getCountryCallingCode(newCountry)}`.\n        // The code assumes that \"no phone number has been entered by the user\",\n        // and no `value` property has been passed, so the `phoneNumber` parameter\n        // of `_getInitialPhoneDigits({ value, phoneNumber, ... })` is `undefined`.\n        phoneDigits: _getInitialPhoneDigits({\n          value: undefined,\n          defaultCountry: newDefaultCountry\n        }),\n        // `value` is `undefined` and it stays so.\n        value: undefined\n      };\n    }\n  }\n\n  // If a new `value` is set externally.\n  // (e.g. as a result of an ajax API request\n  //  to get user's phone after page loaded)\n  // The first part — `newValue !== prevValue` —\n  // is basically `props.value !== prevProps.value`\n  // so it means \"if value property was changed externally\".\n  // The second part — `newValue !== value` —\n  // is for ignoring the `getDerivedStateFromProps()` call\n  // which happens in `this.onChange()` right after `this.setState()`.\n  // If this `getDerivedStateFromProps()` call isn't ignored\n  // then the country flag would reset on each input.\n  if (!valuesAreEqual(newValue, prevValue) && !valuesAreEqual(newValue, value)) {\n    var phoneNumber;\n    var parsedCountry;\n    if (newValue) {\n      // Validate that the newly-supplied `value` is in `E.164` format.\n      // Because sometimes people attempt to supply a `value` like \"+1 (879) 490-8676\".\n      // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/231#note_2016334796\n      if (newValue) {\n        validateE164Number(newValue);\n      }\n      phoneNumber = parsePhoneNumber(newValue, metadata);\n      var supportedCountries = getSupportedCountries(countries, metadata);\n      if (phoneNumber && phoneNumber.country) {\n        // Ignore `else` because all countries are supported in metadata.\n        /* istanbul ignore next */\n        if (!supportedCountries || supportedCountries.indexOf(phoneNumber.country) >= 0) {\n          parsedCountry = phoneNumber.country;\n        }\n      } else {\n        parsedCountry = getCountryForPartialE164Number(newValue, {\n          country: undefined,\n          countries: supportedCountries,\n          metadata: metadata\n        });\n\n        // In cases when multiple countries correspond to the same country calling code,\n        // the phone number digits of `newValue` have to be matched against country-specific\n        // regular expressions in order to determine the exact country.\n        // Sometimes, that algorithm can't decide for sure which country does the phone number belong to,\n        // for example when the digits of `newValue` don't match any of those regular expressions.\n        // and the country of the phone number couldn't be determined.\n        // In those cases, people prefer the component to show the flag of the `defaultCountry`\n        // if the phone number could potentially belong to that `defaultCountry`.\n        // At least that's how the component behaves when a user pastes an international\n        // phone number into the input field: for example, when `defaultCountry` is `\"US\"`\n        // and the user pastes value \"+1 555 555 5555\" into the input field, it keep showing \"US\" flag.\n        // So when setting new `value` property externally, the component should behave the same way:\n        // it should select the `defaultCountry` when the new `value` could potentially belong\n        // to that country in cases when the exact country can't be determined.\n        // https://github.com/catamphetamine/react-phone-number-input/issues/413#issuecomment-1536219404\n        if (!parsedCountry) {\n          if (newDefaultCountry) {\n            if (newValue.indexOf(getInternationalPhoneNumberPrefix(newDefaultCountry, metadata)) === 0) {\n              parsedCountry = newDefaultCountry;\n            }\n          }\n        }\n      }\n    }\n    var userCountrySelectionHistoryStateUpdate;\n    if (newValue) {\n      // If the latest country that has been manually selected by the user\n      // no longer corresponds to the new value then reset it.\n      if (latestCountrySelectedByUser) {\n        var couldNewValueCorrespondToLatestCountrySelectedByUser = parsedCountry ? latestCountrySelectedByUser === parsedCountry : couldNumberBelongToCountry(newValue, latestCountrySelectedByUser, metadata);\n        if (couldNewValueCorrespondToLatestCountrySelectedByUser) {\n          if (!parsedCountry) {\n            parsedCountry = latestCountrySelectedByUser;\n          }\n        } else {\n          userCountrySelectionHistoryStateUpdate = {\n            latestCountrySelectedByUser: undefined\n          };\n        }\n      }\n    } else {\n      // When the `value` property is being reset \"externally\",\n      // reset any tracking of the country that the user has previously selected.\n      userCountrySelectionHistoryStateUpdate = {\n        latestCountrySelectedByUser: undefined,\n        hasUserSelectedACountry: undefined\n      };\n    }\n    return _objectSpread(_objectSpread({}, userCountrySelectionHistoryStateUpdate), {}, {\n      phoneDigits: _getInitialPhoneDigits({\n        phoneNumber: phoneNumber,\n        value: newValue,\n        defaultCountry: newDefaultCountry\n      }),\n      value: newValue,\n      country: newValue ? parsedCountry : newDefaultCountry\n    });\n  }\n\n  // `defaultCountry` didn't change.\n  // `value` didn't change.\n  // `phoneDigits` didn't change, because `value` didn't change.\n  //\n  // So no need to update state.\n}\nexport function valuesAreEqual(value1, value2) {\n  // If `value` has been set to `null` externally then convert it to `undefined`.\n  //\n  // For example, `react-hook-form` sets `value` to `null` when the user clears the input.\n  // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/164\n  // In that case, without this conversion of `null` to `undefined`, it would reset\n  // the selected country to `defaultCountry` because in that case `newValue !== value`\n  // because `null !== undefined`.\n  //\n  // Historically, empty `value` is encoded as `undefined`.\n  // Perhaps empty `value` would be better encoded as `null` instead.\n  // But because that would be a potentially breaking change for some people,\n  // it's left as is for the current \"major\" version of this library.\n  //\n  if (value1 === null) {\n    value1 = undefined;\n  }\n  if (value2 === null) {\n    value2 = undefined;\n  }\n  return value1 === value2;\n}","map":{"version":3,"names":["getInitialPhoneDigits","getCountryForPartialE164Number","parsePhoneNumber","couldNumberBelongToCountry","validateE164Number","getInternationalPhoneNumberPrefix","isCountrySupportedWithError","getSupportedCountries","getPhoneInputWithCountryStateUpdateFromNewProps","props","prevProps","state","metadata","countries","newDefaultCountry","defaultCountry","newValue","value","newReset","reset","international","displayInitialValueAsLocalNumber","initialValueFormat","prevDefaultCountry","prevValue","prevReset","country","hasUserSelectedACountry","latestCountrySelectedByUser","_getInitialPhoneDigits","parameters","_objectSpread","useNationalFormat","phoneDigits","undefined","isNewDefaultCountrySupported","noValueHasBeenEnteredByTheUser","noValueHasBeenEntered","valuesAreEqual","phoneNumber","parsedCountry","supportedCountries","indexOf","userCountrySelectionHistoryStateUpdate","couldNewValueCorrespondToLatestCountrySelectedByUser","value1","value2"],"sources":["/Users/pratapsingh/Library/Mobile Documents/com~apple~CloudDocs/Hotstarproject/desney-plus-hotstar/node_modules/react-phone-number-input/source/helpers/getPhoneInputWithCountryStateUpdateFromNewProps.js"],"sourcesContent":["import {\r\n\tgetInitialPhoneDigits,\r\n\tgetCountryForPartialE164Number,\r\n\tparsePhoneNumber,\r\n\tcouldNumberBelongToCountry\r\n} from './phoneInputHelpers.js'\r\n\r\nimport { validateE164Number } from './isE164Number.js'\r\n\r\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix.js'\r\n\r\nimport {\r\n\tisCountrySupportedWithError,\r\n\tgetSupportedCountries\r\n} from './countries.js'\r\n\r\nexport default function getPhoneInputWithCountryStateUpdateFromNewProps(props, prevProps, state) {\r\n\tconst {\r\n\t\tmetadata,\r\n\t\tcountries,\r\n\t\tdefaultCountry: newDefaultCountry,\r\n\t\tvalue: newValue,\r\n\t\treset: newReset,\r\n\t\tinternational,\r\n\t\t// `displayInitialValueAsLocalNumber` property has been\r\n\t\t// superceded by `initialValueFormat` property.\r\n\t\tdisplayInitialValueAsLocalNumber,\r\n\t\tinitialValueFormat\r\n\t} = props\r\n\r\n\tconst {\r\n\t\tdefaultCountry: prevDefaultCountry,\r\n\t\tvalue: prevValue,\r\n\t\treset: prevReset\r\n\t} = prevProps\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tvalue,\r\n\t\t// If the user has already manually selected a country\r\n\t\t// then don't override that already selected country\r\n\t\t// if the `defaultCountry` property changes.\r\n\t\t// That's what `hasUserSelectedACountry` flag is for.\r\n\t\thasUserSelectedACountry,\r\n\t\tlatestCountrySelectedByUser\r\n\t} = state\r\n\r\n\tconst _getInitialPhoneDigits = (parameters) => getInitialPhoneDigits({\r\n\t\t...parameters,\r\n\t\tinternational,\r\n\t\tuseNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === 'national',\r\n\t\tmetadata\r\n\t})\r\n\r\n\t// Some users requested a way to reset the component\r\n\t// (both number `<input/>` and country `<select/>`).\r\n\t// Whenever `reset` property changes both number `<input/>`\r\n\t// and country `<select/>` are reset.\r\n\t// It's not implemented as some instance `.reset()` method\r\n\t// because `ref` is forwarded to `<input/>`.\r\n\t// It's also not replaced with just resetting `country` on\r\n\t// external `value` reset, because a user could select a country\r\n\t// and then not input any `value`, and so the selected country\r\n\t// would be \"stuck\", if not using this `reset` property.\r\n\t// https://github.com/catamphetamine/react-phone-number-input/issues/300\r\n\tif (newReset !== prevReset) {\r\n\t\treturn {\r\n\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t}),\r\n\t\t\tvalue: undefined,\r\n\t\t\tcountry: newDefaultCountry,\r\n\t\t\tlatestCountrySelectedByUser: undefined,\r\n\t\t\thasUserSelectedACountry: undefined\r\n\t\t}\r\n\t}\r\n\r\n\t// `value` is the value currently shown in the component:\r\n\t// it's stored in the component's `state`, and it's not the `value` property.\r\n\t// `prevValue` is \"previous `value` property\".\r\n\t// `newValue` is \"new `value` property\".\r\n\r\n\t// If the default country changed\r\n\t// (e.g. in case of ajax GeoIP detection after page loaded)\r\n\t// then select it, but only if the user hasn't already manually\r\n\t// selected a country, and no phone number has been manually entered so far.\r\n\t// Because if the user has already started inputting a phone number\r\n\t// then they're okay with no country being selected at all (\"International\")\r\n\t// and they don't want to be disturbed, don't want their input to be screwed, etc.\r\n\tif (newDefaultCountry !== prevDefaultCountry) {\r\n\t\tconst isNewDefaultCountrySupported = !newDefaultCountry || isCountrySupportedWithError(newDefaultCountry, metadata)\r\n\t\tconst noValueHasBeenEnteredByTheUser = (\r\n\t\t\t// By default, \"no value has been entered\" means `value` is `undefined`.\r\n\t\t\t!value ||\r\n\t\t\t// When `international` is `true`, and some country has been pre-selected,\r\n\t\t\t// then the `<input/>` contains a pre-filled value of `+${countryCallingCode}${leadingDigits}`,\r\n\t\t\t// so in case of `international` being `true`, \"the user hasn't entered anything\" situation\r\n\t\t\t// doesn't just mean `value` is `undefined`, but could also mean `value` is `+${countryCallingCode}`.\r\n\t\t\t(international && value === _getInitialPhoneDigits({\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tdefaultCountry: prevDefaultCountry\r\n\t\t\t}))\r\n\t\t)\r\n\t\t// Only update the `defaultCountry` property if no phone number\r\n\t\t// has been entered by the user or pre-set by the application.\r\n\t\tconst noValueHasBeenEntered = !newValue && noValueHasBeenEnteredByTheUser\r\n\t\tif (!hasUserSelectedACountry && isNewDefaultCountrySupported && noValueHasBeenEntered) {\r\n\t\t\treturn {\r\n\t\t\t\tcountry: newDefaultCountry,\r\n\t\t\t\t// If `phoneDigits` is empty, then automatically select the new `country`\r\n\t\t\t\t// and set `phoneDigits` to `+{getCountryCallingCode(newCountry)}`.\r\n\t\t\t\t// The code assumes that \"no phone number has been entered by the user\",\r\n\t\t\t\t// and no `value` property has been passed, so the `phoneNumber` parameter\r\n\t\t\t\t// of `_getInitialPhoneDigits({ value, phoneNumber, ... })` is `undefined`.\r\n\t\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\t\tvalue: undefined,\r\n\t\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t\t}),\r\n\t\t\t\t// `value` is `undefined` and it stays so.\r\n\t\t\t\tvalue: undefined\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If a new `value` is set externally.\r\n\t// (e.g. as a result of an ajax API request\r\n\t//  to get user's phone after page loaded)\r\n\t// The first part — `newValue !== prevValue` —\r\n\t// is basically `props.value !== prevProps.value`\r\n\t// so it means \"if value property was changed externally\".\r\n\t// The second part — `newValue !== value` —\r\n\t// is for ignoring the `getDerivedStateFromProps()` call\r\n\t// which happens in `this.onChange()` right after `this.setState()`.\r\n\t// If this `getDerivedStateFromProps()` call isn't ignored\r\n\t// then the country flag would reset on each input.\r\n\tif (!valuesAreEqual(newValue, prevValue) && !valuesAreEqual(newValue, value)) {\r\n\t\tlet phoneNumber\r\n\t\tlet parsedCountry\r\n\t\tif (newValue) {\r\n\t\t\t// Validate that the newly-supplied `value` is in `E.164` format.\r\n\t\t\t// Because sometimes people attempt to supply a `value` like \"+1 (879) 490-8676\".\r\n\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/231#note_2016334796\r\n\t\t\tif (newValue) {\r\n\t\t\t\tvalidateE164Number(newValue)\r\n\t\t\t}\r\n\t\t\tphoneNumber = parsePhoneNumber(newValue, metadata)\r\n\t\t\tconst supportedCountries = getSupportedCountries(countries, metadata)\r\n\t\t\tif (phoneNumber && phoneNumber.country) {\r\n\t\t\t\t// Ignore `else` because all countries are supported in metadata.\r\n\t\t\t\t/* istanbul ignore next */\r\n\t\t\t\tif (!supportedCountries || supportedCountries.indexOf(phoneNumber.country) >= 0) {\r\n\t\t\t\t\tparsedCountry = phoneNumber.country\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tparsedCountry = getCountryForPartialE164Number(newValue, {\r\n\t\t\t\t\tcountry: undefined,\r\n\t\t\t\t\tcountries: supportedCountries,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t})\r\n\r\n\t\t\t\t// In cases when multiple countries correspond to the same country calling code,\r\n\t\t\t\t// the phone number digits of `newValue` have to be matched against country-specific\r\n\t\t\t\t// regular expressions in order to determine the exact country.\r\n\t\t\t\t// Sometimes, that algorithm can't decide for sure which country does the phone number belong to,\r\n\t\t\t\t// for example when the digits of `newValue` don't match any of those regular expressions.\r\n\t\t\t\t// and the country of the phone number couldn't be determined.\r\n\t\t\t\t// In those cases, people prefer the component to show the flag of the `defaultCountry`\r\n\t\t\t\t// if the phone number could potentially belong to that `defaultCountry`.\r\n\t\t\t\t// At least that's how the component behaves when a user pastes an international\r\n\t\t\t\t// phone number into the input field: for example, when `defaultCountry` is `\"US\"`\r\n\t\t\t\t// and the user pastes value \"+1 555 555 5555\" into the input field, it keep showing \"US\" flag.\r\n\t\t\t\t// So when setting new `value` property externally, the component should behave the same way:\r\n\t\t\t\t// it should select the `defaultCountry` when the new `value` could potentially belong\r\n\t\t\t\t// to that country in cases when the exact country can't be determined.\r\n\t\t\t\t// https://github.com/catamphetamine/react-phone-number-input/issues/413#issuecomment-1536219404\r\n\t\t\t\tif (!parsedCountry) {\r\n\t\t\t\t\tif (newDefaultCountry) {\r\n\t\t\t\t\t\tif (newValue.indexOf(getInternationalPhoneNumberPrefix(newDefaultCountry, metadata)) === 0) {\r\n\t\t\t\t\t\t\tparsedCountry = newDefaultCountry\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet userCountrySelectionHistoryStateUpdate\r\n\t\tif (newValue) {\r\n\t\t\t// If the latest country that has been manually selected by the user\r\n\t\t\t// no longer corresponds to the new value then reset it.\r\n\t\t\tif (latestCountrySelectedByUser) {\r\n\t\t\t\tconst couldNewValueCorrespondToLatestCountrySelectedByUser =\r\n\t\t\t\t\tparsedCountry\r\n\t\t\t\t\t\t? latestCountrySelectedByUser === parsedCountry\r\n\t\t\t\t\t\t: couldNumberBelongToCountry(newValue, latestCountrySelectedByUser, metadata)\r\n\r\n\t\t\t\tif (couldNewValueCorrespondToLatestCountrySelectedByUser) {\r\n\t\t\t\t\tif (!parsedCountry) {\r\n\t\t\t\t\t\tparsedCountry = latestCountrySelectedByUser\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuserCountrySelectionHistoryStateUpdate = {\r\n\t\t\t\t\t\tlatestCountrySelectedByUser: undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// When the `value` property is being reset \"externally\",\r\n\t\t\t// reset any tracking of the country that the user has previously selected.\r\n\t\t\tuserCountrySelectionHistoryStateUpdate = {\r\n\t\t\t\tlatestCountrySelectedByUser: undefined,\r\n\t\t\t\thasUserSelectedACountry: undefined\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\t...userCountrySelectionHistoryStateUpdate,\r\n\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\tphoneNumber,\r\n\t\t\t\tvalue: newValue,\r\n\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t}),\r\n\t\t\tvalue: newValue,\r\n\t\t\tcountry: newValue ? parsedCountry : newDefaultCountry\r\n\t\t}\r\n\t}\r\n\r\n\t// `defaultCountry` didn't change.\r\n\t// `value` didn't change.\r\n\t// `phoneDigits` didn't change, because `value` didn't change.\r\n\t//\r\n\t// So no need to update state.\r\n}\r\n\r\nexport function valuesAreEqual(value1, value2) {\r\n\t// If `value` has been set to `null` externally then convert it to `undefined`.\r\n\t//\r\n\t// For example, `react-hook-form` sets `value` to `null` when the user clears the input.\r\n\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/164\r\n\t// In that case, without this conversion of `null` to `undefined`, it would reset\r\n\t// the selected country to `defaultCountry` because in that case `newValue !== value`\r\n\t// because `null !== undefined`.\r\n\t//\r\n\t// Historically, empty `value` is encoded as `undefined`.\r\n\t// Perhaps empty `value` would be better encoded as `null` instead.\r\n\t// But because that would be a potentially breaking change for some people,\r\n\t// it's left as is for the current \"major\" version of this library.\r\n\t//\r\n\tif (value1 === null) {\r\n\t\tvalue1 = undefined\r\n\t}\r\n\tif (value2 === null) {\r\n\t\tvalue2 = undefined\r\n\t}\r\n\treturn value1 === value2\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}